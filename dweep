#!/bin/bash

# dweep - ICS Development Workspace Setup Tool
# Version: 1.0.0
# Compatible: macOS M3 and later

set -e

DWEEP_VERSION="1.0.0"
WORKSPACES_DIR="$HOME/workspaces"
ICS_STANDARDS_REPO="https://github.com/IslandComputingServices/ICSCoreStandards.git"
DWEEP_CONFIG_DIR="$HOME/.dweep"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check system requirements
check_requirements() {
    log_info "Checking system requirements..."
    
    # Check macOS version (M3 and later)
    if [[ "$(uname)" != "Darwin" ]]; then
        log_error "dweep requires macOS (M3 and later)"
        exit 1
    fi
    
    # Check for required tools
    local required_tools=("git" "gh" "q")
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log_error "Required tool '$tool' is not installed"
            case $tool in
                "git")
                    echo "Install Git: https://git-scm.com/download/mac or 'brew install git'"
                    ;;
                "gh")
                    echo "Install GitHub CLI: 'brew install gh'"
                    ;;
                "q")
                    echo "Install Amazon Q CLI: https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/q-cli.html"
                    ;;
            esac
            exit 1
        fi
    done
    
    # Check Git configuration
    check_git_configuration
    
    log_success "System requirements met"
}

# Check Git configuration
check_git_configuration() {
    log_info "Checking Git configuration..."
    
    # Check if Git is configured with user name and email
    local git_user_name
    local git_user_email
    
    git_user_name=$(git config --global user.name 2>/dev/null || echo "")
    git_user_email=$(git config --global user.email 2>/dev/null || echo "")
    
    if [[ -z "$git_user_name" || -z "$git_user_email" ]]; then
        log_error "Git is not configured properly"
        echo
        echo "Please configure Git with your name and email:"
        echo "  git config --global user.name \"Your Name\""
        echo "  git config --global user.email \"your.email@example.com\""
        echo
        exit 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status &>/dev/null; then
        log_warning "GitHub CLI is not authenticated"
        echo
        echo "Please authenticate with GitHub CLI:"
        echo "  gh auth login"
        echo
        echo "This is required to access ICS Core Standards repository."
        read -p "Continue anyway? (y/N): " continue_choice
        if [[ "$continue_choice" != "y" && "$continue_choice" != "Y" ]]; then
            exit 1
        fi
    fi
    
    log_success "Git configuration verified"
}

# Download ICS Core Standards with error handling
download_ics_standards() {
    local workspace_path="$1"
    
    log_info "Downloading ICS Core Standards from GitHub..."
    cd "$workspace_path"
    
    # Attempt to clone the repository with detailed error handling
    if ! git clone "$ICS_STANDARDS_REPO" ICSCoreStandards 2>&1; then
        local clone_exit_code=$?
        log_error "Failed to download ICS Core Standards repository"
        echo
        echo "Possible causes:"
        echo "1. Repository not accessible: $ICS_STANDARDS_REPO"
        echo "2. Network connectivity issues"
        echo "3. GitHub authentication required"
        echo "4. Repository permissions not granted"
        echo
        echo "Troubleshooting steps:"
        echo "1. Check network connection"
        echo "2. Verify GitHub CLI authentication: gh auth status"
        echo "3. Test repository access: gh repo view IslandComputingServices/ICSCoreStandards"
        echo "4. Contact repository administrator for access"
        echo
        
        # Try to provide more specific error information
        if [[ $clone_exit_code -eq 128 ]]; then
            echo "Git clone failed with exit code 128 (repository not found or access denied)"
        fi
        
        exit 1
    fi
    
    # Verify the clone was successful
    if [[ ! -d "ICSCoreStandards" ]]; then
        log_error "ICS Core Standards directory not created successfully"
        exit 1
    fi
    
    # Verify essential files exist
    if [[ ! -f "ICSCoreStandards/README.md" ]]; then
        log_warning "ICS Core Standards may not have downloaded completely"
        echo "Repository cloned but essential files may be missing"
    fi
    
    log_success "ICS Core Standards downloaded successfully"
}

# Initialize dweep configuration
init_dweep() {
    if [[ ! -d "$DWEEP_CONFIG_DIR" ]]; then
        mkdir -p "$DWEEP_CONFIG_DIR"
        log_info "Created dweep configuration directory: $DWEEP_CONFIG_DIR"
    fi
    
    if [[ ! -d "$WORKSPACES_DIR" ]]; then
        mkdir -p "$WORKSPACES_DIR"
        log_info "Created workspaces directory: $WORKSPACES_DIR"
    fi
}

# Show usage information
show_usage() {
    cat << EOF
dweep - ICS Development Workspace Setup Tool v$DWEEP_VERSION

USAGE:
    dweep -setup workspace           Setup a new development workspace
    dweep spec create <system-name>  Create unified specifications repository
    dweep spec link <repo-url>       Link existing specifications repository
    dweep ai init                    Initialize AI context management
    dweep ai read                    Read current AI context
    dweep ai update                  Update AI context with current state
    dweep ai log "<decision>"        Log AI decision to context
    dweep -list                      List existing workspaces
    dweep -help                      Show this help message
    dweep -version                   Show version information

EXAMPLES:
    dweep -setup workspace           # Interactive workspace setup (includes AI context)
    dweep spec create IslandManagementService  # Create unified specs repo
    dweep ai read                    # Get current context for AI session
    dweep ai update                  # Refresh context after changes
    dweep ai log "Fixed Smithy validation errors"  # Log decision

AI CONTEXT WORKFLOW:
    1. Always run 'dweep ai read' before AI interactions
    2. Include context in AI prompts for continuity
    3. Run 'dweep ai update' after significant changes
    4. Use 'dweep ai log' to record important decisions

REQUIREMENTS:
    - macOS M3 and later
    - Git, GitHub CLI (gh), and Q CLI installed
    - ~/workspaces directory (created automatically)

DEPLOYMENT CONFIGS:
    - Place in /packages/{SystemName}{Type}/deploymentconfig/
    - Examples: IslandManagementServiceService, UserDashboardWebsite
    - /scripts may symlink to deploymentconfig directory

EOF
}

# List existing workspaces
list_workspaces() {
    log_info "Existing workspaces in $WORKSPACES_DIR:"
    
    if [[ ! -d "$WORKSPACES_DIR" ]]; then
        log_warning "No workspaces directory found. Run 'dweep -setup workspace' to create your first workspace."
        return
    fi
    
    local count=0
    for workspace in "$WORKSPACES_DIR"/*; do
        if [[ -d "$workspace" ]]; then
            local name=$(basename "$workspace")
            local type_file="$workspace/.dweep/workspace_type"
            local type="Unknown"
            
            if [[ -f "$type_file" ]]; then
                type=$(cat "$type_file")
            fi
            
            echo "  â€¢ $name ($type)"
            ((count++))
        fi
    done
    
    if [[ $count -eq 0 ]]; then
        log_warning "No workspaces found. Run 'dweep -setup workspace' to create your first workspace."
    else
        log_success "Found $count workspace(s)"
    fi
}

# Setup workspace
setup_workspace() {
    log_info "Starting ICS workspace setup..."
    
    # Get user information
    local username=$(whoami)
    
    echo
    echo "=== ICS Workspace Setup ==="
    echo
    
    # Ask for workspace type
    echo "Select workspace type:"
    echo "1) New Service (microservice/API)"
    echo "2) New Worker (background processing)"
    echo "3) New Website (frontend application)"
    echo "4) Existing System (checkout existing codebase)"
    echo
    read -p "Enter choice (1-4): " workspace_type
    
    case $workspace_type in
        1) setup_new_service "$username" ;;
        2) setup_new_worker "$username" ;;
        3) setup_new_website "$username" ;;
        4) setup_existing_system "$username" ;;
        *) log_error "Invalid choice. Please run dweep -setup workspace again." && exit 1 ;;
    esac
}

# Setup new service workspace
setup_new_service() {
    local username="$1"
    local service_name
    local workspace_name
    
    echo
    read -p "Enter service name (e.g., IslandManagementService): " service_name
    
    if [[ -z "$service_name" ]]; then
        log_error "Service name cannot be empty"
        exit 1
    fi
    
    workspace_name="${service_name}-${username}"
    read -p "Workspace name [$workspace_name]: " custom_name
    
    if [[ -n "$custom_name" ]]; then
        workspace_name="$custom_name"
    fi
    
    create_workspace "$workspace_name" "service" "$service_name"
    setup_new_system_structure "$workspace_name" "service"
}

# Setup new worker workspace
setup_new_worker() {
    local username="$1"
    local worker_name
    local workspace_name
    
    echo
    read -p "Enter worker name (e.g., IslandProvisioningWorker): " worker_name
    
    if [[ -z "$worker_name" ]]; then
        log_error "Worker name cannot be empty"
        exit 1
    fi
    
    workspace_name="${worker_name}-${username}"
    read -p "Workspace name [$workspace_name]: " custom_name
    
    if [[ -n "$custom_name" ]]; then
        workspace_name="$custom_name"
    fi
    
    create_workspace "$workspace_name" "worker" "$worker_name"
    setup_new_system_structure "$workspace_name" "worker"
}

# Setup new website workspace
setup_new_website() {
    local username="$1"
    local website_name
    local workspace_name
    
    echo
    read -p "Enter website name (e.g., IslandConsole): " website_name
    
    if [[ -z "$website_name" ]]; then
        log_error "Website name cannot be empty"
        exit 1
    fi
    
    workspace_name="${website_name}-${username}"
    read -p "Workspace name [$workspace_name]: " custom_name
    
    if [[ -n "$custom_name" ]]; then
        workspace_name="$custom_name"
    fi
    
    create_workspace "$workspace_name" "website" "$website_name"
    setup_new_system_structure "$workspace_name" "website"
}

# Setup existing system workspace
setup_existing_system() {
    local username="$1"
    local system_name
    local workspace_name
    
    echo
    read -p "Enter existing system name: " system_name
    
    if [[ -z "$system_name" ]]; then
        log_error "System name cannot be empty"
        exit 1
    fi
    
    workspace_name="${system_name}-${username}"
    read -p "Workspace name [$workspace_name]: " custom_name
    
    if [[ -n "$custom_name" ]]; then
        workspace_name="$custom_name"
    fi
    
    create_workspace "$workspace_name" "existing" "$system_name"
    setup_existing_system_structure "$workspace_name" "$system_name"
}

# Create workspace directory structure
create_workspace() {
    local workspace_name="$1"
    local workspace_type="$2"
    local system_name="$3"
    
    local workspace_path="$WORKSPACES_DIR/$workspace_name"
    
    if [[ -d "$workspace_path" ]]; then
        log_error "Workspace '$workspace_name' already exists"
        exit 1
    fi
    
    log_info "Creating workspace: $workspace_name"
    
    # Create workspace structure
    mkdir -p "$workspace_path"
    mkdir -p "$workspace_path/.dweep"
    
    # Store workspace metadata
    echo "$workspace_type" > "$workspace_path/.dweep/workspace_type"
    echo "$system_name" > "$workspace_path/.dweep/system_name"
    echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" > "$workspace_path/.dweep/created_at"
    echo "$DWEEP_VERSION" > "$workspace_path/.dweep/dweep_version"
    
    # Create .gitignore to prevent workspace commits
    cat > "$workspace_path/.gitignore" << 'EOF'
# WORKSPACE GITIGNORE - PREVENTS ACCIDENTAL COMMITS
# This workspace should NEVER be committed to version control

# Ignore everything by default
*

# Allow this .gitignore file
!.gitignore

# Allow README files for documentation
!README.md
!WORKSPACE_STRUCTURE.md
!AI_AGENT_INSTRUCTIONS.md

# Individual repositories manage their own version control
# Workspace is only a container for multiple repositories
EOF
    
    log_success "Created workspace directory: $workspace_path"
    log_warning "IMPORTANT: Workspace is NOT a git repository and should NEVER be committed"
}

# Setup new system structure
setup_new_system_structure() {
    local workspace_name="$1"
    local system_type="$2"
    local workspace_path="$WORKSPACES_DIR/$workspace_name"
    
    log_info "Setting up new $system_type structure..."
    
    # Download ICS Core Standards with proper error handling
    download_ics_standards "$workspace_path"
    
    # Create multi-repository workspace structure
    mkdir -p "packages"
    mkdir -p "specifications"
    mkdir -p "docs"
    mkdir -p "scripts"
    
    # Create layer-specific package directories
    mkdir -p "packages/data-access-layer"
    mkdir -p "packages/business-layer"
    mkdir -p "packages/api-layer"
    mkdir -p "packages/presentation-layer"
    mkdir -p "packages/shared"
    
    # Create initial specification templates
    create_specification_templates "$workspace_path" "$system_type"
    
    # Create AI agent instructions
    create_ai_instructions "$workspace_path" "$system_type"
    
    # Create workspace structure documentation
    create_workspace_structure_doc "$workspace_path"
    
    log_success "Workspace setup complete!"
    show_next_steps "$workspace_name" "new"
}

# Setup existing system structure
setup_existing_system_structure() {
    local workspace_name="$1"
    local system_name="$2"
    local workspace_path="$WORKSPACES_DIR/$workspace_name"
    
    log_info "Setting up existing system structure..."
    
    # Download ICS Core Standards with proper error handling
    download_ics_standards "$workspace_path"
    
    # Create multi-repository workspace structure for existing system
    mkdir -p "packages"
    mkdir -p "specifications"
    mkdir -p "docs"
    mkdir -p "scripts"
    
    # Create layer-specific package directories
    mkdir -p "packages/data-access-layer"
    mkdir -p "packages/business-layer"
    mkdir -p "packages/api-layer"
    mkdir -p "packages/presentation-layer"
    mkdir -p "packages/shared"
    
    # Create workspace structure documentation
    create_workspace_structure_doc "$workspace_path"
    
    log_info "Workspace structure created for existing system"
    log_warning "Please clone your existing repositories into the appropriate packages/{layer}/ directories"
    
    log_success "Workspace setup complete!"
    show_next_steps "$workspace_name" "existing"
}

# Create specification templates
create_specification_templates() {
    local workspace_path="$1"
    local system_type="$2"
    
    log_info "Creating specification templates..."
    
    # Create API Model specification template
    cat > "$workspace_path/specifications/api-model-specification.md" << 'EOF'
# API Model Specification

**Status:** DRAFT
**Parent Documents:** [ICSCoreStandards/specifications/api-design-specifications.md]

## API Models

### [ModelName]ApiModel

```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "[ModelName]",
  "type": "object",
  "required": [],
  "properties": {
    
  }
}
```

## Validation Rules

- MUST comply with JSON Schema draft 4
- MUST follow AWS-compatible field naming
- MUST include required field specifications

## Change Management

- Changes require team approval
- MUST maintain backward compatibility
- MUST update version on breaking changes
EOF

    # Create Architecture specification template
    cat > "$workspace_path/specifications/architecture-specification.md" << 'EOF'
# Architecture Specification

**Status:** DRAFT
**Parent Documents:** [ICSCoreStandards/specifications/architecture-specifications.md]

## System Architecture

### Layer Architecture
- **API Layer:** [Description]
- **Business Layer:** [Description]  
- **Data Access Layer:** [Description]

### Component Design
- [Component descriptions]

### Integration Points
- [External system integrations]

## Security Requirements
- [Security specifications]

## Scalability Requirements
- [Performance and scaling requirements]
EOF

    # Create Design specification template
    cat > "$workspace_path/specifications/design-specification.md" << 'EOF'
# Design Specification

**Status:** DRAFT
**Parent Documents:** [ICSCoreStandards/specifications/design-specifications.md]

## Design Patterns

### Selected Patterns
- [Pattern name]: [Justification]

### Component Design
- [Component designs]

### Interface Definitions
- [Interface specifications]

## Implementation Guidelines
- [Implementation details]
EOF

    # Create Data Model specification template
    cat > "$workspace_path/specifications/data-model-specification.md" << 'EOF'
# Data Model Specification

**Status:** DRAFT
**Parent Documents:** [ICSCoreStandards/specifications/layer-architecture-specifications.md]

## Data Models

### [ModelName]DataModel

```sql
-- Database schema definition
```

## Abstract Data Types

### [ModelName]AbstractDataType

```java
// ADT interface definition
```

## Data Access Patterns
- [Data access specifications]
EOF

    log_success "Created specification templates"
}

# Create workspace structure documentation
create_workspace_structure_doc() {
    local workspace_path="$1"
    
    log_info "Creating workspace structure documentation..."
    
    cat > "$workspace_path/WORKSPACE_STRUCTURE.md" << 'EOF'
# Workspace Structure

This workspace follows ICS standards for multi-repository system development.

## Directory Structure

```
{WorkspaceName}/
â”œâ”€â”€ ICSCoreStandards/           # ICS standards (auto-downloaded)
â”œâ”€â”€ packages/                   # All packages/repositories for this system
â”‚   â”œâ”€â”€ data-access-layer/      # Data Access Layer repositories
â”‚   â”œâ”€â”€ business-layer/         # Business Logic Layer repositories
â”‚   â”œâ”€â”€ api-layer/              # API Layer repositories
â”‚   â”œâ”€â”€ presentation-layer/     # Presentation Layer repositories
â”‚   â””â”€â”€ shared/                 # Shared libraries and common types
â”œâ”€â”€ specifications/             # System-wide specifications
â”œâ”€â”€ docs/                       # System documentation
â”œâ”€â”€ scripts/                    # Build and deployment scripts
â”œâ”€â”€ AI_AGENT_INSTRUCTIONS.md    # AI agent guidance
â””â”€â”€ WORKSPACE_STRUCTURE.md      # This file
```

## Multi-Repository Architecture

### Layer Organization
Each layer can contain one or more repositories:

**Data Access Layer (`packages/data-access-layer/`)**
- `{component}-dal/` - Data access repositories
- `{model}-data-model/` - Data model repositories
- `{model}-adt/` - Abstract Data Type repositories

**Business Layer (`packages/business-layer/`)**
- `{component}-business/` - Business logic repositories
- `{domain}-services/` - Domain service repositories

**API Layer (`packages/api-layer/`)**
- `{component}-api/` - API repositories
- `{model}-api-model/` - API model repositories

**Presentation Layer (`packages/presentation-layer/`)**
- `{component}-ui/` - Frontend repositories
- `{app}-web/` - Web application repositories

**Shared (`packages/shared/`)**
- `{model}-common-types/` - Common type repositories
- `{component}-interfaces/` - Shared interface repositories
- `{utility}-libs/` - Utility library repositories

### Repository Creation Process

1. **Create New Repository**
```bash
cd packages/{layer}/
git clone https://github.com/org/{repo-name}.git
# OR create new repository
mkdir {repo-name} && cd {repo-name} && git init
```

2. **Follow Layer Standards**
- Each repository must follow ICS layer architecture standards
- Repositories must only import from allowed layers
- Cross-layer communication must use defined interfaces

3. **Maintain Dependencies**
- Document inter-repository dependencies
- Use semantic versioning for repository releases
- Maintain dependency compatibility matrices

## Development Workflow

### 1. System-Wide Specifications
Create specifications in `specifications/` that cover the entire system:
- System architecture specification
- Cross-component integration specification
- Shared data model specifications

### 2. Repository-Specific Development
For each repository in `packages/`:
- Follow ICS development process (Specifications â†’ Interfaces â†’ Implementation)
- Maintain repository-specific documentation
- Ensure layer compliance

### 3. Integration and Testing
- Test repository interactions
- Validate layer boundary compliance
- Ensure system-wide functionality

## AI Agent Guidelines

When working with multi-repository workspaces:

### Repository Creation
- Ask for approval before creating new repositories
- Follow naming conventions: `{component}-{layer}`
- Place repositories in appropriate layer directories

### Cross-Repository Development
- Maintain clear boundaries between repositories
- Use only approved interfaces for communication
- Document dependencies between repositories

### Layer Compliance
- Ensure each repository follows its layer's constraints
- Validate that repositories only import from allowed layers
- Maintain proper abstraction levels
EOF

    log_success "Created workspace structure documentation"
}

# Create AI agent instructions
create_ai_instructions() {
    local workspace_path="$1"
    local system_type="$2"
    
    log_info "Creating AI agent instructions..."
    
    cat > "$workspace_path/AI_AGENT_INSTRUCTIONS.md" << EOF
# AI Agent Instructions for $(basename "$workspace_path")

## CRITICAL: Follow ICS Standards

You MUST follow all standards in \`ICSCoreStandards/\` directory.

## Multi-Repository Workspace Structure

This workspace supports multiple packages/repositories organized by layer:

### Repository Organization
- **Data Access Layer**: \`packages/data-access-layer/\`
- **Business Layer**: \`packages/business-layer/\`
- **API Layer**: \`packages/api-layer/\`
- **Presentation Layer**: \`packages/presentation-layer/\`
- **Shared**: \`packages/shared/\`

### Repository Creation Rules
- MUST ask for approval before creating new repositories
- MUST follow naming convention: \`{component}-{layer}\`
- MUST place repositories in appropriate layer directories
- MUST document inter-repository dependencies

## Development Process

### Phase 1: System-Wide Specification Creation
1. **MUST** create system-wide specifications in \`specifications/\`:
   - System Architecture Specification
   - Cross-Component Integration Specification
   - Shared Data Model Specifications
   - API Contract Specifications

2. **MUST** get approval for each specification before proceeding

### Phase 2: Repository-Specific Specifications
For each repository in \`packages/\`:
1. **MUST** create repository-specific specifications:
   - Component API Model Specification
   - Component Architecture Specification
   - Component Design Specification
   - Component Data Model Specification

2. **MUST** ensure specifications align with system-wide specifications

### Phase 3: Interface Generation
1. **MUST** generate shared interfaces in \`packages/shared/\`:
   - Cross-layer communication interfaces
   - Common type definitions
   - Shared contract specifications

2. **MUST** finalize all contracts before implementation

### Phase 4: Layer Implementation
1. **MUST** implement repositories in layer order:
   - Data Access Layer repositories
   - Business Logic Layer repositories
   - API Layer repositories
   - Presentation Layer repositories

2. **MUST** maintain layer boundaries between repositories

## Repository Management

### Creating New Repositories
\`\`\`bash
# Ask for approval first
# Then create in appropriate layer directory
cd packages/{layer}/
mkdir {component}-{layer}
cd {component}-{layer}
git init
\`\`\`

### Repository Dependencies
- MUST document dependencies between repositories
- MUST use semantic versioning for repository releases
- MUST maintain compatibility matrices
- MUST NOT create circular dependencies

## Technology Stack (Approved)

### Backend Repositories:
- Java 17+ with Spring Boot
- PostgreSQL for data persistence
- Redis for caching

### Frontend Repositories:
- React 18+ with TypeScript
- Next.js for SSR/SSG
- Tailwind CSS for styling

### Shared Libraries:
- Common type definitions
- Utility libraries
- Interface specifications

## Layer Constraints (Per Repository)

### Data Access Layer Repositories
- MUST only import: Data Models, Abstract Data Types, Infrastructure libs
- MUST NOT import: API Models, Business Layer, Presentation Layer
- MUST provide ADT instances to Business Layer

### Business Layer Repositories
- MUST only import: Abstract Data Types, Common Types, Shared interfaces
- MUST NOT import: Data Models, API Models, Presentation Layer
- MUST be framework-agnostic

### API Layer Repositories
- MUST only import: API Models, Common Types, Shared interfaces
- MUST NOT import: Data Models, Business Layer implementation
- MUST provide semantic validation

### Presentation Layer Repositories
- MUST only communicate through API Layer
- MUST NOT directly access Business or Data Access layers
- MUST implement proper separation of concerns

### Shared Repositories
- MUST contain only: Common Types, Interfaces, Utilities
- MUST NOT contain layer-specific implementation
- MUST be importable by multiple layers (where allowed)

## Commands to Run

### Initial System Setup:
\`\`\`bash
cd $(basename "$workspace_path")
q chat "Create system-wide specifications for $system_type with multi-repository architecture following ICS standards"
\`\`\`

### Repository Creation:
\`\`\`bash
q chat "Create new repository for {component} in {layer} following ICS standards and system specifications"
\`\`\`

### Cross-Repository Integration:
\`\`\`bash
q chat "Generate shared interfaces for cross-repository communication following approved specifications"
\`\`\`

### Repository Implementation:
\`\`\`bash
q chat "Implement {repository-name} following layer constraints and approved specifications"
\`\`\`

## Multi-Repository Validation

### Before Creating New Repository:
- [ ] Repository purpose clearly defined
- [ ] Layer placement appropriate
- [ ] Dependencies documented
- [ ] Naming convention followed
- [ ] Team approval obtained

### Before Cross-Repository Changes:
- [ ] Impact analysis completed
- [ ] Interface compatibility maintained
- [ ] Version compatibility verified
- [ ] Integration tests updated

### Before Repository Integration:
- [ ] Layer boundaries maintained
- [ ] Only approved interfaces used
- [ ] Dependencies properly managed
- [ ] Integration tests passing

## Repository Approval Process

1. **System Design**: Create system-wide specifications
2. **Repository Planning**: Define repository structure and dependencies
3. **Team Approval**: Get approval for repository creation
4. **Repository Creation**: Create repository in appropriate layer
5. **Specification Creation**: Create repository-specific specifications
6. **Implementation**: Follow layer constraints and use approved interfaces

**Remember: Each repository MUST follow ICS layer architecture standards and maintain proper boundaries!**
EOF

    log_success "Created AI agent instructions"
}

# Show next steps
show_next_steps() {
    local workspace_name="$1"
    local setup_type="$2"
    
    echo
    echo "=== Next Steps ==="
    echo
    log_success "Workspace '$workspace_name' is ready!"
    echo
    echo "1. Navigate to your workspace:"
    echo "   cd ~/workspaces/$workspace_name"
    echo
    echo "2. Review the workspace structure:"
    echo "   open WORKSPACE_STRUCTURE.md"
    echo
    echo "3. Review the ICS Core Standards:"
    echo "   open ICSCoreStandards/README.md"
    echo
    
    if [[ "$setup_type" == "new" ]]; then
        echo "4. Start with system-wide specifications (REQUIRED):"
        echo "   q chat \"Create system-wide specifications for multi-repository $system_type following ICS standards\""
        echo
        echo "5. Review AI Agent Instructions:"
        echo "   open AI_AGENT_INSTRUCTIONS.md"
        echo
        echo "6. Create repositories in packages/{layer}/ directories"
        echo "7. Follow the specification â†’ interface â†’ implementation process for each repository"
    else
        echo "4. Clone your existing repositories into packages/{layer}/ directories"
        echo
        echo "5. Ensure existing code follows ICS layer architecture standards"
    fi
    
    echo
    log_info "Happy coding! ðŸš€"
}

# Create specifications repository
create_spec_repository() {
    local system_name="$1"
    local repo_name="${system_name}Specifications"
    
    log_info "Creating unified specifications repository: $repo_name"
    
    # Check if we're in a workspace
    if [[ ! -f ".dweep/config.json" ]]; then
        log_error "Not in a dweep workspace. Run from workspace root."
        exit 1
    fi
    
    # Create repository directory
    mkdir -p "$repo_name"
    cd "$repo_name"
    
    # Initialize git repository
    git init
    
    # Create unified specification and documentation structure
    mkdir -p {requirements,api,architecture,user-guides,deployment,operations,troubleshooting}
    
    # Create README
    cat > README.md << EOF
# ${system_name} Specifications

Unified specifications and documentation repository for ${system_name}.

## Structure

### Specifications
- \`requirements/\` - System requirements and user stories
- \`api/\` - API specifications and contracts
- \`architecture/\` - System architecture documents

### Documentation
- \`user-guides/\` - End user documentation
- \`deployment/\` - Deployment and installation guides
- \`operations/\` - Operational procedures and runbooks
- \`troubleshooting/\` - Common issues and solutions

## Guidelines

- All specifications must be reviewed before implementation
- Changes to specifications require separate commits from code
- Use clear, measurable acceptance criteria
- Keep documentation current with system changes
- Follow ICS specification and documentation standards

## License

Copyright Â© 2025 Island Computing Services. All rights reserved.
EOF
    
    # Create initial specification files
    cat > requirements/system-overview.md << EOF
# ${system_name} System Overview

## Purpose

[Describe the system purpose and objectives]

## Scope

[Define what is included and excluded from this system]

## Stakeholders

[List key stakeholders and their roles]

## Success Criteria

[Define measurable success criteria]
EOF
    
    # Create initial user guide
    cat > user-guides/getting-started.md << EOF
# ${system_name} Getting Started Guide

## Overview

[Brief system overview for end users]

## Prerequisites

[List what users need before using the system]

## Quick Start

[Step-by-step quick start instructions]

## Next Steps

[Links to more detailed documentation]
EOF
    
    # Initial commit
    git add .
    git commit -m "Initial commit: ${system_name} unified specifications repository

- Combined specifications and documentation structure
- Requirements, API, architecture specifications
- User guides, deployment, operations documentation
- Initial system overview and getting started templates
- README with guidelines for spec/doc separation"
    
    # Create GitHub repository
    gh repo create "IslandComputingServices/$repo_name" --public --description "${system_name} unified specifications and documentation repository"
    
    # Add remote and push
    git remote add origin "https://github.com/IslandComputingServices/$repo_name.git"
    git push -u origin main
    
    cd ..
    
    # Create symlink at workspace root
    ln -sf "$repo_name" specifications
    
    log_success "Created unified specifications repository: $repo_name"
    log_info "Linked as: specifications/ -> $repo_name/"
    log_info "Contains both specifications and documentation"
}

# AI Context Management Functions

# Initialize AI context for workspace
init_ai_context() {
    local workspace_dir="$1"
    
    log_info "Initializing AI context management for workspace"
    
    # Create AI context directory
    mkdir -p "$workspace_dir/.ai-context"
    
    # Create context files
    cat > "$workspace_dir/.ai-context/session-state.md" << 'EOF'
# AI Session Context

## Current Session
- **Started**: [TIMESTAMP]
- **Workspace**: [WORKSPACE_NAME]
- **System**: [SYSTEM_NAME]
- **Last Updated**: [TIMESTAMP]

## Active Rules
- Follow ICS Core Standards
- Use dweep for all workspace operations
- Validate directory structure before operations
- Place deployment configs in /packages/{SystemName}{Type}/deploymentconfig/
- Specifications in unified {SystemName}Specifications repository

## Current State
- **Repositories**: [LIST_REPOS]
- **Recent Changes**: [RECENT_COMMITS]
- **Active Branch**: [CURRENT_BRANCH]
- **Pending Tasks**: [TASK_LIST]

## Key Decisions Made
- [DECISION_LOG]

## Next Steps
- [ACTION_ITEMS]
EOF

    cat > "$workspace_dir/.ai-context/context-template.md" << 'EOF'
# AI Context Template

Use this template for every AI interaction:

## Session Continuity Check
"Previous context: [BRIEF_SUMMARY]
If this is a new session or model change, please acknowledge and confirm understanding of current state."

## Current Context
- Workspace: [WORKSPACE_PATH]
- System: [SYSTEM_NAME]
- Active repositories: [REPO_LIST]
- Recent changes: [LAST_3_COMMITS]
- Current task: [CURRENT_TASK]

## Rules Reminder
- Use dweep for workspace operations
- Follow ICS Core Standards
- Validate directory structure
- Update context after significant changes
EOF

    cat > "$workspace_dir/.ai-context/update-context.sh" << 'EOF'
#!/bin/bash
# AI Context Update Script

CONTEXT_DIR=".ai-context"
SESSION_FILE="$CONTEXT_DIR/session-state.md"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Update session timestamp
sed -i '' "s/Last Updated.*/Last Updated**: $TIMESTAMP/" "$SESSION_FILE"

# Update current branch
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "N/A")
sed -i '' "s/Active Branch.*/Active Branch**: $CURRENT_BRANCH/" "$SESSION_FILE"

# Update recent commits
RECENT_COMMITS=$(git log --oneline -3 2>/dev/null | sed 's/^/  - /' || echo "  - No git repository")
sed -i '' "/Recent Changes/,/Active Branch/ { /Recent Changes/!{ /Active Branch/!d; }; }" "$SESSION_FILE"
sed -i '' "/Recent Changes.*/ a\\
$RECENT_COMMITS" "$SESSION_FILE"

# Update repository list
REPOS=$(find packages -name ".git" -type d 2>/dev/null | sed 's|packages/||; s|/.git||' | sed 's/^/  - /' || echo "  - No repositories found")
sed -i '' "/Repositories/,/Recent Changes/ { /Repositories/!{ /Recent Changes/!d; }; }" "$SESSION_FILE"
sed -i '' "/Repositories.*/ a\\
$REPOS" "$SESSION_FILE"

echo "AI context updated at $TIMESTAMP"
EOF

    chmod +x "$workspace_dir/.ai-context/update-context.sh"
    
    # Create AI context reading script
    cat > "$workspace_dir/.ai-context/read-context.sh" << 'EOF'
#!/bin/bash
# AI Context Reader Script

CONTEXT_DIR=".ai-context"
SESSION_FILE="$CONTEXT_DIR/session-state.md"

echo "=== AI SESSION CONTEXT ==="
echo
if [[ -f "$SESSION_FILE" ]]; then
    cat "$SESSION_FILE"
else
    echo "No AI context found. Run 'dweep ai init' to initialize."
fi
echo
echo "=== END CONTEXT ==="
EOF

    chmod +x "$workspace_dir/.ai-context/read-context.sh"
    
    # Initialize session state with current info
    cd "$workspace_dir"
    WORKSPACE_NAME=$(basename "$PWD")
    SYSTEM_NAME=$(cat .dweep/system_name 2>/dev/null || echo "Unknown")
    
    # Update template with actual values
    sed -i '' "s/\[TIMESTAMP\]/$TIMESTAMP/g" "$workspace_dir/.ai-context/session-state.md"
    sed -i '' "s/\[WORKSPACE_NAME\]/$WORKSPACE_NAME/g" "$workspace_dir/.ai-context/session-state.md"
    sed -i '' "s/\[SYSTEM_NAME\]/$SYSTEM_NAME/g" "$workspace_dir/.ai-context/session-state.md"
    
    # Run initial context update
    ./.ai-context/update-context.sh
    
    log_success "AI context management initialized"
    log_info "Use 'dweep ai read' to get current context"
    log_info "Use 'dweep ai update' to refresh context"
}

# Read AI context
read_ai_context() {
    if [[ ! -f ".ai-context/session-state.md" ]]; then
        log_error "No AI context found. Run 'dweep ai init' first."
        exit 1
    fi
    
    ./.ai-context/read-context.sh
}

# Update AI context
update_ai_context() {
    if [[ ! -f ".ai-context/update-context.sh" ]]; then
        log_error "No AI context found. Run 'dweep ai init' first."
        exit 1
    fi
    
    # Update session timestamp and basic info
    ./.ai-context/update-context.sh
    
    # Maintain 24-hour decision history
    maintain_decision_history
}

# Maintain decision history for last 24 hours
maintain_decision_history() {
    local session_file=".ai-context/session-state.md"
    local history_file=".ai-context/decision-history.md"
    local temp_file=$(mktemp)
    
    # Create clean history file
    cat > "$temp_file" << 'EOF'
# AI Decision History (Last 24 Hours)

## Recent Decisions
EOF
    
    # Collect all unique decisions from both files
    {
        grep "^\- \[" "$session_file" 2>/dev/null || true
        grep "^\- \[" "$history_file" 2>/dev/null || true
    } | grep -v "\[DECISION_LOG\]" | sort -u | tail -20 >> "$temp_file"
    
    # Replace history file
    mv "$temp_file" "$history_file"
    
    # Update session file with clean structure
    update_session_with_history
}

# Update session file to include persistent history
update_session_with_history() {
    local session_file=".ai-context/session-state.md"
    local history_file=".ai-context/decision-history.md"
    local temp_session=$(mktemp)
    
    # Copy everything up to "Key Decisions Made"
    sed '/## Key Decisions Made/,$d' "$session_file" > "$temp_session"
    
    # Add clean decision section
    echo "## Key Decisions Made (Last 24 Hours)" >> "$temp_session"
    grep "^\- \[" "$history_file" 2>/dev/null | head -10 >> "$temp_session" || echo "- No recent decisions" >> "$temp_session"
    
    echo "" >> "$temp_session"
    echo "## Next Steps" >> "$temp_session"
    echo "- [ACTION_ITEMS]" >> "$temp_session"
    
    # Replace session file
    mv "$temp_session" "$session_file"
}

# Add decision to context log
log_ai_decision() {
    local decision="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local decision_entry="- [$timestamp] $decision"
    
    if [[ ! -f ".ai-context/session-state.md" ]]; then
        log_error "No AI context found. Run 'dweep ai init' first."
        exit 1
    fi
    
    # Add to history file directly (avoid duplicates)
    local history_file=".ai-context/decision-history.md"
    if [[ -f "$history_file" ]] && ! grep -Fq "$decision_entry" "$history_file"; then
        sed -i '' "/## Recent Decisions/a\\
$decision_entry" "$history_file"
    fi
    
    log_info "Decision logged: $decision"
    
    # Update context to maintain clean history
    maintain_decision_history
}

# Link existing specifications repository
link_spec_repository() {
    local repo_url="$1"
    local repo_name
    
    # Extract repository name from URL
    repo_name=$(basename "$repo_url" .git)
    
    log_info "Linking specifications repository: $repo_name"
    
    # Check if we're in a workspace
    if [[ ! -f ".dweep/config.json" ]]; then
        log_error "Not in a dweep workspace. Run from workspace root."
        exit 1
    fi
    
    # Clone repository
    git clone "$repo_url"
    
    # Create symlink at workspace root
    ln -sf "$repo_name" specifications
    
    log_success "Linked specifications repository: $repo_name"
    log_info "Available as: specifications/ -> $repo_name/"
}

# Main function
main() {
    case "${1:-}" in
        -setup)
            if [[ "${2:-}" == "workspace" ]]; then
                check_requirements
                init_dweep
                setup_workspace
                # Initialize AI context after workspace setup
                init_ai_context "$(pwd)"
            else
                log_error "Usage: dweep -setup workspace"
                exit 1
            fi
            ;;
        spec)
            case "${2:-}" in
                create)
                    if [[ -n "${3:-}" ]]; then
                        create_spec_repository "$3"
                        update_ai_context
                        log_ai_decision "Created specifications repository: ${3}Specifications"
                    else
                        log_error "Usage: dweep spec create <system-name>"
                        exit 1
                    fi
                    ;;
                link)
                    if [[ -n "${3:-}" ]]; then
                        link_spec_repository "$3"
                        update_ai_context
                        log_ai_decision "Linked specifications repository: $3"
                    else
                        log_error "Usage: dweep spec link <repo-url>"
                        exit 1
                    fi
                    ;;
                *)
                    log_error "Usage: dweep spec {create|link} <args>"
                    exit 1
                    ;;
            esac
            ;;
        ai)
            case "${2:-}" in
                init)
                    init_ai_context "$(pwd)"
                    ;;
                read)
                    read_ai_context
                    ;;
                update)
                    update_ai_context
                    ;;
                log)
                    if [[ -n "${3:-}" ]]; then
                        log_ai_decision "$3"
                    else
                        log_error "Usage: dweep ai log \"<decision>\""
                        exit 1
                    fi
                    ;;
                *)
                    log_error "Usage: dweep ai {init|read|update|log} [args]"
                    exit 1
                    ;;
            esac
            ;;
        -list)
            list_workspaces
            ;;
        -help|--help|-h)
            show_usage
            ;;
        -version|--version|-v)
            echo "dweep version $DWEEP_VERSION"
            ;;
        *)
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
